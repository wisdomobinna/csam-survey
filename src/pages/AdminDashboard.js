// src/pages/AdminDashboard.js - Updated for Prolific Integration
import React, { useState, useEffect } from 'react';
import { useNavigate } from 'react-router-dom';
import { collection, getDocs, doc, deleteDoc, writeBatch, setDoc, serverTimestamp } from 'firebase/firestore';
import { ref, getDownloadURL } from 'firebase/storage';
import { db, storage } from '../firebase/config';
import {
  Box,
  Container,
  Heading,
  VStack,
  HStack,
  Text,
  Button,
  Card,
  CardBody,
  CardHeader,
  Stat,
  StatLabel,
  StatNumber,
  StatHelpText,
  SimpleGrid,
  Badge,
  Table,
  Thead,
  Tbody,
  Tr,
  Th,
  Td,
  TableContainer,
  useToast,
  Alert,
  AlertIcon,
  AlertTitle,
  AlertDescription,
  Spinner,
  Flex,
  Progress,
  Modal,
  ModalOverlay,
  ModalContent,
  ModalHeader,
  ModalFooter,
  ModalBody,
  ModalCloseButton,
  useDisclosure,
  UnorderedList,
  ListItem,
  InputGroup,
  InputLeftElement,
  Input,
  Select,
  Textarea,
  Code,
  NumberInput,
  NumberInputField,
  NumberInputStepper,
  NumberIncrementStepper,
  NumberDecrementStepper,
  FormControl,
  FormLabel,
  FormHelperText,
  Divider,
  Accordion,
  AccordionItem,
  AccordionButton,
  AccordionPanel,
  AccordionIcon,
} from '@chakra-ui/react';

// Import your utilities
import { fixAllUserAssignments } from '../utils/fixUserAssignments';
import { 
  getAssignmentStats, 
  resetImageAssignments, 
  verifySetup, 
  clearAllData 
} from '../utils/firebaseSetup';

const AdminDashboard = () => {
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState('');
  const [users, setUsers] = useState([]);
  const [stats, setStats] = useState({
    totalUsers: 0,
    completedSurveys: 0,
    activeUsers: 0,
    testUsers: 0,
    prolificUsers: 0,
    preAssignedUsers: 0,
    autoGenerated: 0, // NEW: Count of auto-generated login IDs
    totalImages: 0,
    assignedImages: 0,
    averageCompletion: 0
  });
  const [imageStats, setImageStats] = useState(null);
  const [selectedUser, setSelectedUser] = useState(null);
  const [searchTerm, setSearchTerm] = useState('');
  const [filterType, setFilterType] = useState('all');
  const [prolificUrl, setProlificUrl] = useState('');
  
  // Participant creation state
  const [participantCount, setParticipantCount] = useState(10);
  const [participantPrefix, setParticipantPrefix] = useState('P');
  const [startingNumber, setStartingNumber] = useState(1);
  const [imagesPerParticipant, setImagesPerParticipant] = useState(10);
  const [createLoading, setCreateLoading] = useState(false);

  const { isOpen: isUserModalOpen, onOpen: onUserModalOpen, onClose: onUserModalClose } = useDisclosure();
  const { isOpen: isStatsModalOpen, onOpen: onStatsModalOpen, onClose: onStatsModalClose } = useDisclosure();
  const { isOpen: isProlificModalOpen, onOpen: onProlificModalOpen, onClose: onProlificModalClose } = useDisclosure();
  const { isOpen: isCreateModalOpen, onOpen: onCreateModalOpen, onClose: onCreateModalClose } = useDisclosure();

  const navigate = useNavigate();
  const toast = useToast();

  useEffect(() => {
    const isAdmin = sessionStorage.getItem('isAdmin');
    const loginId = sessionStorage.getItem('userLoginId');
    
    if (!isAdmin || loginId !== 'ADMIN') {
      toast({
        title: 'Access Denied',
        description: 'Admin credentials required',
        status: 'error',
        duration: 3000,
      });
      navigate('/login');
      return;
    }
    
    loadDashboardData();
    generateProlificUrl();
  }, [navigate, toast]);

  // UPDATED: Better user type detection for new Prolific integration
  const determineUserType = (userData, userId) => {
    // Check for auto-generated login IDs (new Prolific system)
    const isAutoGenerated = userId.startsWith('login_') && userId.includes('_');
    
    // Check for test users
    const isTest = userData.source === 'test' || 
                   userData.prolificData?.isTestUser || 
                   userId.includes('TEST') ||
                   userData.testParticipant ||
                   (userData.prolificPid && userData.prolificPid.includes('TEST'));
    
    // Check for Prolific users (including new system)
    const isProlific = (userData.source === 'prolific' || 
                       userData.prolificData?.prolificPid ||
                       userData.prolificPid) && !isTest;
    
    // Check for pre-assigned participants
    const isPreAssigned = userData.preAssigned || 
                         userData.source === 'pre-assigned' ||
                         userData.preAssignmentDetails;
    
    return {
      isAutoGenerated,
      isTest,
      isProlific,
      isPreAssigned
    };
  };

  const loadDashboardData = async () => {
    try {
      setLoading(true);
      console.log('Loading admin dashboard data...');
      
      // Load users
      const usersRef = collection(db, 'loginIDs');
      const usersSnapshot = await getDocs(usersRef);
      
      const usersData = [];
      let completedCount = 0;
      let activeCount = 0;
      let testCount = 0;
      let prolificCount = 0;
      let preAssignedCount = 0;
      let autoGeneratedCount = 0; // NEW
      let totalAssignedImages = 0;
      let totalCompletedImages = 0;
      
      usersSnapshot.forEach(doc => {
        const userData = doc.data();
        const userId = doc.id;
        
        // Skip admin user
        if (userId === 'ADMIN') return;
        
        // UPDATED: Use new user type detection
        const userType = determineUserType(userData, userId);
        
        const isCompleted = userData.surveyCompleted || false;
        const isActive = userData.isActive !== false;
        const demographicsCompleted = userData.demographicsCompleted || false;
        const hasConsented = userData.hasConsented || false;
        
        // UPDATED: Get display information for new Prolific system
        let displayInfo = {
          primaryId: userId,
          prolificPid: null,
          displayLabel: userId
        };
        
        if (userData.prolificPid || userData.prolificData?.prolificPid) {
          displayInfo.prolificPid = userData.prolificPid || userData.prolificData?.prolificPid;
          if (userType.isAutoGenerated) {
            displayInfo.displayLabel = `${displayInfo.prolificPid} (${userId.substring(0, 12)}...)`;
          }
        }
        
        usersData.push({
          id: userId,
          displayId: userData.displayId || userId,
          displayInfo, // NEW: Enhanced display information
          ...userData,
          ...userType, // Spread the user type flags
          isCompleted,
          isActive,
          demographicsCompleted,
          hasConsented,
          completedImages: userData.completedImages || 0,
          totalImages: userData.assignedImages?.length || 0,
          completionPercentage: userData.assignedImages?.length > 0 
            ? Math.round((userData.completedImages || 0) / userData.assignedImages.length * 100)
            : 0
        });
        
        // UPDATED: Count using new detection logic
        if (isCompleted) completedCount++;
        if (isActive) activeCount++;
        if (userType.isTest) testCount++;
        if (userType.isProlific) prolificCount++;
        if (userType.isPreAssigned) preAssignedCount++;
        if (userType.isAutoGenerated) autoGeneratedCount++; // NEW
        
        totalAssignedImages += userData.assignedImages?.length || 0;
        totalCompletedImages += userData.completedImages || 0;
      });
      
      // Sort users by creation date (newest first)
      usersData.sort((a, b) => {
        const dateA = a.createdAt?.toDate?.() || new Date(0);
        const dateB = b.createdAt?.toDate?.() || new Date(0);
        return dateB - dateA;
      });
      
      setUsers(usersData);
      
      // Calculate average completion rate
      const averageCompletion = usersData.length > 0 
        ? Math.round(totalCompletedImages / Math.max(totalAssignedImages, 1) * 100)
        : 0;
      
      setStats({
        totalUsers: usersData.length,
        completedSurveys: completedCount,
        activeUsers: activeCount,
        testUsers: testCount,
        prolificUsers: prolificCount,
        preAssignedUsers: preAssignedCount,
        autoGenerated: autoGeneratedCount, // NEW
        totalImages: totalAssignedImages,
        assignedImages: totalAssignedImages,
        averageCompletion
      });
      
      // Load image assignment statistics
      try {
        const assignmentStats = await getAssignmentStats();
        setImageStats(assignmentStats);
      } catch (error) {
        console.warn('Could not load image statistics:', error);
      }
      
      console.log('Dashboard data loaded:', {
        users: usersData.length,
        prolific: prolificCount,
        autoGenerated: autoGeneratedCount,
        preAssigned: preAssignedCount,
        test: testCount
      });
      
    } catch (error) {
      console.error('Error loading dashboard data:', error);
      setError(error.message);
      toast({
        title: 'Error Loading Dashboard',
        description: error.message,
        status: 'error',
        duration: 5000,
      });
    } finally {
      setLoading(false);
    }
  };

  const generateProlificUrl = () => {
    const baseUrl = window.location.origin;
    const prolificParams = new URLSearchParams({
      PROLIFIC_PID: '{{%PROLIFIC_PID%}}',
      STUDY_ID: '{{%STUDY_ID%}}',
      SESSION_ID: '{{%SESSION_ID%}}'
    });
    
    const fullUrl = `${baseUrl}/login?${prolificParams.toString()}`;
    setProlificUrl(fullUrl);
  };

  // FIXED: GET AVAILABLE IMAGES FOR ASSIGNMENT - VERIFIES IMAGES EXIST
  const getAvailableImagesForAssignment = async () => {
    try {
      console.log('Checking available images in Firebase Storage...');
      
      // Check if storage structure exists by testing sample images
      const testImages = [
        { path: 'set1/1.png', set: 'set1' },
        { path: 'set1/100.png', set: 'set1' },
        { path: 'set1/500.png', set: 'set1' },
        { path: 'set2/1201.png', set: 'set2' },
        { path: 'set2/1300.png', set: 'set2' },
        { path: 'set2/1500.png', set: 'set2' }
      ];
      
      let set1Exists = false;
      let set2Exists = false;
      
      console.log('Testing sample images to verify storage structure...');
      
      for (const testImg of testImages) {
        try {
          const imageRef = ref(storage, testImg.path);
          await getDownloadURL(imageRef);
          if (testImg.set === 'set1') {
            set1Exists = true;
          } else {
            set2Exists = true;
          }
          console.log(`âœ“ Found ${testImg.path}`);
        } catch (error) {
          console.warn(`âœ— Test image ${testImg.path} not found`);
        }
      }
      
      if (!set1Exists && !set2Exists) {
        throw new Error('No image sets found in Firebase Storage. Please upload images to set1/ and set2/ folders first.');
      }
      
      if (!set1Exists) {
        console.warn('Warning: No set1 images found. Only set2 will be used.');
      }
      
      if (!set2Exists) {
        console.warn('Warning: No set2 images found. Only set1 will be used.');
      }
      
      const availableImages = [];
      
      // Generate image objects for verified sets
      if (set1Exists) {
        console.log('Adding set1 images (1-1200)...');
        for (let i = 1; i <= 1200; i++) {
          availableImages.push({
            id: `set1_${i}`,
            name: `${i}.png`,
            set: 'set1',
            path: `set1/${i}.png`,
            storageRef: `set1/${i}.png`
          });
        }
      }
      
      if (set2Exists) {
        console.log('Adding set2 images (1201-2400)...');
        for (let i = 1201; i <= 2400; i++) {
          availableImages.push({
            id: `set2_${i}`,
            name: `${i}.png`,
            set: 'set2',
            path: `set2/${i}.png`,
            storageRef: `set2/${i}.png`
          });
        }
      }
      
      // Shuffle for random assignment
      const shuffled = availableImages.sort(() => Math.random() - 0.5);
      
      console.log(`âœ“ Generated ${shuffled.length} available images for assignment`);
      console.log(`  - Set1: ${shuffled.filter(img => img.set === 'set1').length} images`);
      console.log(`  - Set2: ${shuffled.filter(img => img.set === 'set2').length} images`);
      
      if (shuffled.length === 0) {
        throw new Error('No images available for assignment. Please check your Firebase Storage setup.');
      }
      
      return shuffled;
      
    } catch (error) {
      console.error('Error getting available images:', error);
      throw new Error('Failed to get available images for assignment: ' + error.message);
    }
  };

  // CREATE PRE-ASSIGNED PARTICIPANTS WITH FIXED IMAGE ASSIGNMENT
  const createPreAssignedParticipants = async () => {
    try {
      setCreateLoading(true);
      
      console.log('Creating pre-assigned participants...', {
        count: participantCount,
        prefix: participantPrefix,
        startingNumber,
        imagesPerParticipant
      });
      
      // Generate participant IDs
      const participantIds = [];
      for (let i = 0; i < participantCount; i++) {
        const number = (startingNumber + i).toString().padStart(4, '0');
        const participantId = participantPrefix === 'numeric' ? number : `${participantPrefix}${number}`;
        participantIds.push(participantId);
      }
      
      console.log('Generated participant IDs:', participantIds);
      
      // Get available images from storage (with verification)
      const availableImages = await getAvailableImagesForAssignment();
      
      if (availableImages.length < imagesPerParticipant) {
        throw new Error(`Not enough images available. Found ${availableImages.length}, need ${imagesPerParticipant} per participant.`);
      }
      
      // Create participants with image assignments
      const batch = writeBatch(db);
      const set1Images = availableImages.filter(img => img.set === 'set1');
      const set2Images = availableImages.filter(img => img.set === 'set2');
      
      console.log(`Available for assignment: ${set1Images.length} set1 images, ${set2Images.length} set2 images`);
      
      for (let i = 0; i < participantIds.length; i++) {
        const participantId = participantIds[i];
        
        // Assign images (balanced between sets when possible)
        const assignedImages = [];
        
        if (set1Images.length > 0 && set2Images.length > 0) {
          // Both sets available - assign balanced
          const imagesPerSet = Math.floor(imagesPerParticipant / 2);
          
          // Calculate starting indices to ensure different images per participant
          const set1StartIndex = (i * imagesPerSet) % Math.max(1, set1Images.length - imagesPerSet);
          const set2StartIndex = (i * imagesPerSet) % Math.max(1, set2Images.length - imagesPerSet);
          
          // Add images from set1
          for (let j = 0; j < imagesPerSet && j + set1StartIndex < set1Images.length; j++) {
            assignedImages.push(set1Images[set1StartIndex + j]);
          }
          
          // Add images from set2
          for (let j = 0; j < imagesPerSet && j + set2StartIndex < set2Images.length; j++) {
            assignedImages.push(set2Images[set2StartIndex + j]);
          }
          
          // If we need one more image (odd number), alternate between sets
          if (assignedImages.length < imagesPerParticipant) {
            const extraSet = i % 2 === 0 ? set1Images : set2Images;
            const extraStartIndex = i % 2 === 0 ? set1StartIndex : set2StartIndex;
            const extraIndex = extraStartIndex + imagesPerSet;
            
            if (extraIndex < extraSet.length) {
              assignedImages.push(extraSet[extraIndex]);
            } else if (assignedImages.length < availableImages.length) {
              // Fallback: take any available image
              const usedIds = new Set(assignedImages.map(img => img.id));
              const unusedImage = availableImages.find(img => !usedIds.has(img.id));
              if (unusedImage) {
                assignedImages.push(unusedImage);
              }
            }
          }
        } else {
          // Only one set available - assign from available set
          const availableSet = set1Images.length > 0 ? set1Images : set2Images;
          const startIndex = (i * imagesPerParticipant) % Math.max(1, availableSet.length - imagesPerParticipant);
          
          for (let j = 0; j < imagesPerParticipant && j + startIndex < availableSet.length; j++) {
            assignedImages.push(availableSet[startIndex + j]);
          }
        }
        
        console.log(`Assigned ${assignedImages.length} images to ${participantId}`);
        console.log(`  - Set1: ${assignedImages.filter(img => img.set === 'set1').length} images`);
        console.log(`  - Set2: ${assignedImages.filter(img => img.set === 'set2').length} images`);
        
        const userRef = doc(db, 'loginIDs', participantId);
        const userData = {
          internalUserId: participantId,
          displayId: participantId,
          assignedImages: assignedImages,
          completedImages: 0,
          completedImageIds: [], // NEW: Initialize array for completed image tracking
          totalImages: assignedImages.length,
          surveyCompleted: false,
          hasConsented: false,
          demographicsCompleted: false, // NEW: Initialize demographics status
          createdAt: serverTimestamp(),
          isActive: true,
          source: 'pre-assigned',
          preAssigned: true,
          preAssignedAt: serverTimestamp(),
          imageAssignmentStatus: 'assigned', // Track assignment status
          preAssignmentDetails: {
            batchCreated: true,
            batchTimestamp: new Date().toISOString(),
            imagesPerParticipant: assignedImages.length,
            set1Count: assignedImages.filter(img => img.set === 'set1').length,
            set2Count: assignedImages.filter(img => img.set === 'set2').length,
            verifiedImages: true // Flag that images were verified to exist
          }
        };
        
        batch.set(userRef, userData);
      }
      
      await batch.commit();
      
      console.log(`Successfully created ${participantIds.length} pre-assigned participants with verified images`);
      
      toast({
        title: 'Participants Created Successfully',
        description: `Created ${participantIds.length} participants with ${imagesPerParticipant} verified images each`,
        status: 'success',
        duration: 5000,
      });
      
      // Close modal and reload data
      onCreateModalClose();
      loadDashboardData();
      
    } catch (error) {
      console.error('Error creating pre-assigned participants:', error);
      toast({
        title: 'Creation Failed',
        description: error.message,
        status: 'error',
        duration: 5000,
        isClosable: true,
      });
    } finally {
      setCreateLoading(false);
    }
  };

  // CREATE QUICK TEST PARTICIPANTS WITH VERIFIED IMAGES
  const createTestParticipants = async () => {
    try {
      setLoading(true);
      
      console.log('Creating test participants with verified pre-assigned images...');
      
      const participantIds = ['TEST_0001', 'TEST_0002', 'TEST_0003', 'TEST_0004', 'TEST_0005'];
      const batch = writeBatch(db);
      
      // Get available images (with verification)
      const availableImages = await getAvailableImagesForAssignment();
      
      if (availableImages.length < 50) { // Need at least 10 images per participant
        throw new Error(`Not enough images for test participants. Found ${availableImages.length}, need at least 50.`);
      }
      
      for (let i = 0; i < participantIds.length; i++) {
        const participantId = participantIds[i];
        console.log(`Creating test participant: ${participantId}`);
        
        // Assign 10 images (5 from each set if possible)
        const set1Images = availableImages.filter(img => img.set === 'set1');
        const set2Images = availableImages.filter(img => img.set === 'set2');
        
        let assignedImages = [];
        
        if (set1Images.length >= 5 && set2Images.length >= 5) {
          // Both sets available
          assignedImages = [
            ...set1Images.slice(i * 5, (i + 1) * 5),
            ...set2Images.slice(i * 5, (i + 1) * 5)
          ];
        } else {
          // Use whatever's available
          const startIndex = i * 10;
          assignedImages = availableImages.slice(startIndex, startIndex + 10);
        }
        
        console.log(`  Assigned ${assignedImages.length} verified images`);
        
        const userRef = doc(db, 'loginIDs', participantId);
        const userData = {
          internalUserId: participantId,
          displayId: participantId,
          assignedImages: assignedImages,
          completedImages: 0,
          completedImageIds: [], // NEW
          totalImages: assignedImages.length,
          surveyCompleted: false,
          hasConsented: false,
          demographicsCompleted: false, // NEW
          createdAt: serverTimestamp(),
          isActive: true,
          source: 'test', // NEW: Set source as 'test'
          preAssigned: true,
          preAssignedAt: serverTimestamp(),
          testParticipant: true,
          imageAssignmentStatus: 'assigned',
          preAssignmentDetails: {
            testParticipant: true,
            verifiedImages: true,
            set1Count: assignedImages.filter(img => img.set === 'set1').length,
            set2Count: assignedImages.filter(img => img.set === 'set2').length
          }
        };
        
        batch.set(userRef, userData);
      }
      
      await batch.commit();
      
      console.log('Test participants created successfully with verified images');
      
      toast({
        title: 'Test Participants Created',
        description: `Created ${participantIds.length} test participants with verified pre-assigned images`,
        status: 'success',
        duration: 5000,
      });
      
      // Reload dashboard data
      loadDashboardData();
      
    } catch (error) {
      console.error('Error creating test participants:', error);
      toast({
        title: 'Creation Failed',
        description: error.message,
        status: 'error',
        duration: 5000,
      });
    } finally {
      setLoading(false);
    }
  };

  const handleDeleteUser = async (userId) => {
    if (!window.confirm(`Are you sure you want to delete user ${userId}? This cannot be undone.`)) {
      return;
    }
    
    try {
      await deleteDoc(doc(db, 'loginIDs', userId));
      
      toast({
        title: 'User Deleted',
        description: `User ${userId} has been removed`,
        status: 'success',
        duration: 3000,
      });
      
      // Reload data
      loadDashboardData();
    } catch (error) {
      console.error('Error deleting user:', error);
      toast({
        title: 'Delete Failed',
        description: error.message,
        status: 'error',
        duration: 5000,
      });
    }
  };

  const handleFixAssignments = async () => {
    if (!window.confirm('Fix all user image assignments? This will update image paths for users with old format names.')) {
      return;
    }
    
    try {
      setLoading(true);
      
      toast({
        title: 'Fixing Assignments',
        description: 'This may take a few minutes...',
        status: 'info',
        duration: 3000,
      });
      
      const result = await fixAllUserAssignments();
      
      toast({
        title: 'Assignment Fix Complete',
        description: `Fixed ${result.successful}/${result.total} users`,
        status: result.failed > 0 ? 'warning' : 'success',
        duration: 5000,
      });
      
      // Reload data
      loadDashboardData();
    } catch (error) {
      console.error('Error fixing assignments:', error);
      toast({
        title: 'Fix Failed',
        description: error.message,
        status: 'error',
        duration: 5000,
      });
    } finally {
      setLoading(false);
    }
  };

  const handleResetAssignments = async () => {
    if (!window.confirm('Reset all image assignment counts? This will reset the tracking of how many times each image has been assigned.')) {
      return;
    }
    
    try {
      await resetImageAssignments();
      
      toast({
        title: 'Assignments Reset',
        description: 'Image assignment counts have been reset',
        status: 'success',
        duration: 3000,
      });
      
      loadDashboardData();
    } catch (error) {
      console.error('Error resetting assignments:', error);
      toast({
        title: 'Reset Failed',
        description: error.message,
        status: 'error',
        duration: 5000,
      });
    }
  };

  const handleClearAllData = async () => {
    if (!window.confirm('WARNING: This will delete ALL user data except admin. This cannot be undone! Type "DELETE" to confirm.')) {
      return;
    }
    
    const confirmation = prompt('Type "DELETE" to confirm:');
    if (confirmation !== 'DELETE') {
      return;
    }
    
    try {
      await clearAllData();
      
      toast({
        title: 'Data Cleared',
        description: 'All user data has been removed',
        status: 'success',
        duration: 3000,
      });
      
      loadDashboardData();
    } catch (error) {
      console.error('Error clearing data:', error);
      toast({
        title: 'Clear Failed',
        description: error.message,
        status: 'error',
        duration: 5000,
      });
    }
  };

  const handleLogout = () => {
    sessionStorage.clear();
    toast({
      title: 'Logged Out',
      description: 'Admin session ended',
      status: 'info',
      duration: 2000,
    });
    navigate('/login');
  };

  const copyToClipboard = (text) => {
    navigator.clipboard.writeText(text);
    toast({
      title: 'Copied',
      description: 'Text copied to clipboard',
      status: 'success',
      duration: 2000,
    });
  };

  // UPDATED: Filter logic for new user types
  const filteredUsers = users.filter(user => {
    const matchesSearch = searchTerm === '' || 
      user.id.toLowerCase().includes(searchTerm.toLowerCase()) ||
      (user.displayId && user.displayId.toLowerCase().includes(searchTerm.toLowerCase())) ||
      (user.displayInfo?.prolificPid && user.displayInfo.prolificPid.toLowerCase().includes(searchTerm.toLowerCase()));
    
    const matchesFilter = filterType === 'all' ||
      (filterType === 'test' && user.isTest) ||
      (filterType === 'prolific' && user.isProlific) ||
      (filterType === 'preassigned' && user.isPreAssigned) ||
      (filterType === 'autogenerated' && user.isAutoGenerated) || // NEW
      (filterType === 'completed' && user.isCompleted) ||
      (filterType === 'active' && user.isActive);
    
    return matchesSearch && matchesFilter;
  });

  const openUserDetails = (user) => {
    setSelectedUser(user);
    onUserModalOpen();
  };

  if (loading && users.length === 0) {
    return (
      <Flex minH="100vh" align="center" justify="center">
        <VStack spacing={4}>
          <Spinner size="xl" color="blue.500" />
          <Text>Loading admin dashboard...</Text>
        </VStack>
      </Flex>
    );
  }

  return (
    <Box minH="100vh" bg="gray.50">
      {/* Header */}
      <Box bg="white" borderBottom="1px" borderColor="gray.200" py={4}>
        <Container maxW="7xl">
          <HStack justify="space-between">
            <HStack spacing={3}>
              <Text fontSize="2xl">ğŸ›¡ï¸</Text>
              <VStack align="start" spacing={0}>
                <Heading size="lg">Admin Dashboard</Heading>
                <Text fontSize="sm" color="gray.600">
                  Image Evaluation Study Management
                </Text>
              </VStack>
            </HStack>
            
            <HStack spacing={3}>
              <Button
                colorScheme="purple"
                onClick={onCreateModalOpen}
                leftIcon={<Text>ğŸ‘¥</Text>}
              >
                Create Participants
              </Button>
              <Button
                colorScheme="blue"
                variant="outline"
                onClick={() => navigate('/setup')}
              >
                ğŸ”§ System Setup
              </Button>
              <Button
                colorScheme="green"
                variant="outline"
                onClick={onProlificModalOpen}
              >
                ğŸ”— Prolific URL
              </Button>
              <Button
                colorScheme="red"
                variant="outline"
                onClick={handleLogout}
              >
                ğŸšª Logout
              </Button>
            </HStack>
          </HStack>
        </Container>
      </Box>

      <Container maxW="7xl" py={6}>
        {error && (
          <Alert status="error" mb={6}>
            <AlertIcon />
            <AlertTitle>Dashboard Error:</AlertTitle>
            <AlertDescription>{error}</AlertDescription>
          </Alert>
        )}

        {/* UPDATED: Statistics Overview with new metrics */}
        <SimpleGrid columns={{ base: 1, md: 2, lg: 6 }} spacing={6} mb={8}>
          <Card>
            <CardBody>
              <Stat>
                <StatLabel>Total Participants</StatLabel>
                <StatNumber>{stats.totalUsers}</StatNumber>
                <StatHelpText>
                  <HStack spacing={1}>
                    <Badge colorScheme="purple" size="sm">{stats.preAssignedUsers} Pre-assigned</Badge>
                  </HStack>
                </StatHelpText>
              </Stat>
            </CardBody>
          </Card>

          <Card>
            <CardBody>
              <Stat>
                <StatLabel>By Source</StatLabel>
                <StatNumber fontSize="md">
                  <VStack spacing={1}>
                    <HStack>
                      <Badge colorScheme="blue" size="sm">{stats.prolificUsers}</Badge>
                      <Text fontSize="xs">Prolific</Text>
                    </HStack>
                    <HStack>
                      <Badge colorScheme="orange" size="sm">{stats.testUsers}</Badge>
                      <Text fontSize="xs">Test</Text>
                    </HStack>
                  </VStack>
                </StatNumber>
              </Stat>
            </CardBody>
          </Card>

          <Card>
            <CardBody>
              <Stat>
                <StatLabel>Auto-Generated IDs</StatLabel>
                <StatNumber>{stats.autoGenerated}</StatNumber>
                <StatHelpText>Prolific auto-login system</StatHelpText>
              </Stat>
            </CardBody>
          </Card>

          <Card>
            <CardBody>
              <Stat>
                <StatLabel>Completed Studies</StatLabel>
                <StatNumber>{stats.completedSurveys}</StatNumber>
                <StatHelpText>
                  {stats.totalUsers > 0 ? Math.round((stats.completedSurveys / stats.totalUsers) * 100) : 0}% completion rate
                </StatHelpText>
              </Stat>
            </CardBody>
          </Card>

          <Card>
            <CardBody>
              <Stat>
                <StatLabel>Image Progress</StatLabel>
                <StatNumber>{stats.averageCompletion}%</StatNumber>
                <StatHelpText>Average completion rate</StatHelpText>
              </Stat>
            </CardBody>
          </Card>

          <Card>
            <CardBody>
              <Stat>
                <StatLabel>Active Users</StatLabel>
                <StatNumber>{stats.activeUsers}</StatNumber>
                <StatHelpText>Currently participating</StatHelpText>
              </Stat>
            </CardBody>
          </Card>
        </SimpleGrid>

        {/* Management Actions */}
        <Card mb={6}>
          <CardHeader>
            <Heading size="md">Management Actions</Heading>
          </CardHeader>
          <CardBody>
            <Accordion allowToggle>
              <AccordionItem>
                <AccordionButton>
                  <Box flex="1" textAlign="left">
                    <Text fontWeight="medium">Participant Management</Text>
                  </Box>
                  <AccordionIcon />
                </AccordionButton>
                <AccordionPanel pb={4}>
                  <HStack spacing={4} wrap="wrap">
                    <Button
                      colorScheme="purple"
                      onClick={onCreateModalOpen}
                    >
                      ğŸ‘¥ Create Participants
                    </Button>
                    
                    <Button
                      colorScheme="orange"
                      variant="outline"
                      onClick={createTestParticipants}
                      isLoading={loading}
                    >
                      ğŸ§ª Quick Test Participants
                    </Button>
                  </HStack>
                </AccordionPanel>
              </AccordionItem>

              <AccordionItem>
                <AccordionButton>
                  <Box flex="1" textAlign="left">
                    <Text fontWeight="medium">System Maintenance</Text>
                  </Box>
                  <AccordionIcon />
                </AccordionButton>
                <AccordionPanel pb={4}>
                  <HStack spacing={4} wrap="wrap">
                    <Button
                      colorScheme="blue"
                      onClick={loadDashboardData}
                      isLoading={loading}
                    >
                      ğŸ”„ Refresh Data
                    </Button>
                    
                    <Button
                      colorScheme="orange"
                      variant="outline"
                      onClick={handleFixAssignments}
                    >
                      ğŸ”§ Fix User Assignments
                    </Button>
                    
                    <Button
                      colorScheme="purple"
                      variant="outline"
                      onClick={onStatsModalOpen}
                    >
                      ğŸ“Š Image Statistics
                    </Button>
                    
                    <Button
                      colorScheme="yellow"
                      variant="outline"
                      onClick={handleResetAssignments}
                    >
                      ğŸ”„ Reset Assignment Counts
                    </Button>
                    
                    <Button
                      colorScheme="red"
                      variant="outline"
                      onClick={handleClearAllData}
                    >
                      ğŸ—‘ï¸ Clear All Data
                    </Button>
                  </HStack>
                </AccordionPanel>
              </AccordionItem>
            </Accordion>
          </CardBody>
        </Card>

        {/* User Management */}
        <Card>
          <CardHeader>
            <HStack justify="space-between">
              <Heading size="md">Participant Management</Heading>
              <HStack spacing={3}>
                <InputGroup maxW="300px">
                  <InputLeftElement>
                    <Text>ğŸ”</Text>
                  </InputLeftElement>
                  <Input
                    placeholder="Search users or Prolific IDs..."
                    value={searchTerm}
                    onChange={(e) => setSearchTerm(e.target.value)}
                  />
                </InputGroup>
                
                <Select
                  value={filterType}
                  onChange={(e) => setFilterType(e.target.value)}
                  maxW="150px"
                >
                  <option value="all">All Users</option>
                  <option value="preassigned">Pre-assigned</option>
                  <option value="prolific">Prolific</option>
                  <option value="autogenerated">Auto-Generated</option>
                  <option value="test">Test</option>
                  <option value="completed">Completed</option>
                  <option value="active">Active</option>
                </Select>
              </HStack>
            </HStack>
          </CardHeader>
          <CardBody>
            <TableContainer>
              <Table variant="simple" size="sm">
                <Thead>
                  <Tr>
                    <Th>User ID / Prolific PID</Th>
                    <Th>Type</Th>
                    <Th>Progress</Th>
                    <Th>Study Status</Th>
                    <Th>Created</Th>
                    <Th>Actions</Th>
                  </Tr>
                </Thead>
                <Tbody>
                  {filteredUsers.map(user => (
                    <Tr key={user.id}>
                      <Td>
                        <VStack align="start" spacing={0}>
                          <Text fontSize="sm" fontFamily="mono">
                            {user.isAutoGenerated && user.displayInfo?.prolificPid ? (
                              <>
                                <Text fontWeight="bold" color="blue.600">
                                  {user.displayInfo.prolificPid}
                                </Text>
                                <Text fontSize="xs" color="gray.500">
                                  {user.id.substring(0, 20)}...
                                </Text>
                              </>
                            ) : (
                              user.id.length > 20 ? `${user.id.substring(0, 20)}...` : user.id
                            )}
                          </Text>
                          {user.displayId && user.displayId !== user.id && (
                            <Text fontSize="xs" color="gray.500" fontFamily="mono">
                              {user.displayId}
                            </Text>
                          )}
                        </VStack>
                      </Td>
                      <Td>
                        <HStack spacing={1} wrap="wrap">
                          {user.isPreAssigned && <Badge colorScheme="purple" size="sm">Pre-assigned</Badge>}
                          {user.isTest && <Badge colorScheme="orange" size="sm">Test</Badge>}
                          {user.isProlific && <Badge colorScheme="blue" size="sm">Prolific</Badge>}
                          {user.isAutoGenerated && <Badge colorScheme="cyan" size="sm">Auto-ID</Badge>}
                          {!user.isTest && !user.isProlific && !user.isPreAssigned && !user.isAutoGenerated && <Badge colorScheme="gray" size="sm">Direct</Badge>}
                        </HStack>
                      </Td>
                      <Td>
                        <VStack align="start" spacing={1}>
                          <Text fontSize="sm">
                            {user.completedImages}/{user.totalImages} images
                          </Text>
                          <Progress
                            value={user.completionPercentage}
                            size="sm"
                            colorScheme={user.completionPercentage === 100 ? "green" : "blue"}
                            w="100px"
                          />
                        </VStack>
                      </Td>
                      <Td>
                        <VStack align="start" spacing={0}>
                          {user.isCompleted ? (
                            <Badge colorScheme="green">âœ… Completed</Badge>
                          ) : (
                            <VStack spacing={1}>
                              <Badge colorScheme={user.hasConsented ? "blue" : "gray"} size="sm">
                                {user.hasConsented ? "âœ… Consented" : "â¸ï¸ No Consent"}
                              </Badge>
                              <Badge colorScheme={user.demographicsCompleted ? "purple" : "gray"} size="sm">
                                {user.demographicsCompleted ? "ğŸ“Š Demographics" : "ğŸ“Š Pending"}
                              </Badge>
                            </VStack>
                          )}
                        </VStack>
                      </Td>
                      <Td>
                        <Text fontSize="xs" color="gray.600">
                          {user.createdAt?.toDate?.()?.toLocaleDateString() || 'Unknown'}
                        </Text>
                      </Td>
                      <Td>
                        <HStack spacing={1}>
                          <Button
                            size="xs"
                            onClick={() => openUserDetails(user)}
                          >
                            ğŸ‘ï¸ View
                          </Button>
                          <Button
                            size="xs"
                            colorScheme="red"
                            variant="outline"
                            onClick={() => handleDeleteUser(user.id)}
                          >
                            ğŸ—‘ï¸ Delete
                          </Button>
                        </HStack>
                      </Td>
                    </Tr>
                  ))}
                </Tbody>
              </Table>
            </TableContainer>
            
            {filteredUsers.length === 0 && (
              <Text textAlign="center" py={8} color="gray.500">
                No users found matching your criteria
              </Text>
            )}
          </CardBody>
        </Card>
      </Container>

      {/* Create Participants Modal - Keep existing */}
      <Modal isOpen={isCreateModalOpen} onClose={onCreateModalClose} size="lg">
        <ModalOverlay />
        <ModalContent>
          <ModalHeader>Create Pre-Assigned Participants</ModalHeader>
          <ModalCloseButton />
          <ModalBody pb={6}>
            <VStack spacing={6}>
              <Alert status="info">
                <AlertIcon />
                <Box>
                  <AlertTitle>Pre-Assignment System</AlertTitle>
                  <AlertDescription>
                    This will create participants with pre-assigned images from Firebase Storage. 
                    Images are verified to exist before assignment.
                  </AlertDescription>
                </Box>
              </Alert>

              <SimpleGrid columns={2} spacing={4} w="full">
                <FormControl>
                  <FormLabel>Number of Participants</FormLabel>
                  <NumberInput
                    value={participantCount}
                    onChange={(value) => setParticipantCount(parseInt(value) || 1)}
                    min={1}
                    max={100}
                  >
                    <NumberInputField />
                    <NumberInputStepper>
                      <NumberIncrementStepper />
                      <NumberDecrementStepper />
                    </NumberInputStepper>
                  </NumberInput>
                  <FormHelperText>How many participants to create</FormHelperText>
                </FormControl>

                <FormControl>
                  <FormLabel>Images per Participant</FormLabel>
                  <NumberInput
                    value={imagesPerParticipant}
                    onChange={(value) => setImagesPerParticipant(parseInt(value) || 10)}
                    min={2}
                    max={20}
                  >
                    <NumberInputField />
                    <NumberInputStepper>
                      <NumberIncrementStepper />
                      <NumberDecrementStepper />
                    </NumberInputStepper>
                  </NumberInput>
                  <FormHelperText>Images to assign to each participant</FormHelperText>
                </FormControl>

                <FormControl>
                  <FormLabel>ID Prefix</FormLabel>
                  <Select
                    value={participantPrefix}
                    onChange={(e) => setParticipantPrefix(e.target.value)}
                  >
                    <option value="P">P (P0001, P0002, ...)</option>
                    <option value="S">S (S0001, S0002, ...)</option>
                    <option value="U">U (U0001, U0002, ...)</option>
                    <option value="numeric">Numeric Only (0001, 0002, ...)</option>
                  </Select>
                  <FormHelperText>Prefix for participant IDs</FormHelperText>
                </FormControl>

                <FormControl>
                  <FormLabel>Starting Number</FormLabel>
                  <NumberInput
                    value={startingNumber}
                    onChange={(value) => setStartingNumber(parseInt(value) || 1)}
                    min={1}
                  >
                    <NumberInputField />
                    <NumberInputStepper>
                      <NumberIncrementStepper />
                      <NumberDecrementStepper />
                    </NumberInputStepper>
                  </NumberInput>
                  <FormHelperText>Starting number for ID sequence</FormHelperText>
                </FormControl>
              </SimpleGrid>

              <Box w="full" p={4} bg="blue.50" borderRadius="md">
                <Text fontWeight="medium" mb={2}>Preview:</Text>
                <Text fontSize="sm" color="gray.700">
                  Will create {participantCount} participants with IDs: {' '}
                  {Array.from({ length: Math.min(3, participantCount) }, (_, i) => {
                    const number = (startingNumber + i).toString().padStart(4, '0');
                    return participantPrefix === 'numeric' ? number : `${participantPrefix}${number}`;
                  }).join(', ')}
                  {participantCount > 3 && ', ...'}
                </Text>
                <Text fontSize="sm" color="gray.700">
                  Each will have {imagesPerParticipant} verified pre-assigned images 
                  ({Math.floor(imagesPerParticipant / 2)} from each set when possible)
                </Text>
              </Box>

              <Alert status="warning" size="sm">
                <AlertIcon />
                <Text fontSize="sm">
                  Make sure your Firebase Storage contains images in set1/ and set2/ folders 
                  before creating participants. Images will be verified during creation.
                </Text>
              </Alert>
            </VStack>
          </ModalBody>
          <ModalFooter>
            <Button mr={3} onClick={onCreateModalClose}>
              Cancel
            </Button>
            <Button
              colorScheme="purple"
              onClick={createPreAssignedParticipants}
              isLoading={createLoading}
              loadingText="Creating & Verifying..."
            >
              Create Participants
            </Button>
          </ModalFooter>
        </ModalContent>
      </Modal>

      {/* UPDATED: User Details Modal with enhanced Prolific info */}
      <Modal isOpen={isUserModalOpen} onClose={onUserModalClose} size="xl">
        <ModalOverlay />
        <ModalContent>
          <ModalHeader>User Details</ModalHeader>
          <ModalCloseButton />
          <ModalBody pb={6}>
            {selectedUser && (
              <VStack spacing={4} align="start">
                <SimpleGrid columns={2} spacing={4} w="full">
                  <Box>
                    <Text fontWeight="bold" mb={1}>Internal ID:</Text>
                    <Code fontSize="xs">{selectedUser.id}</Code>
                  </Box>
                  <Box>
                    <Text fontWeight="bold" mb={1}>Display ID:</Text>
                    <Code fontSize="xs">{selectedUser.displayId || 'N/A'}</Code>
                  </Box>
                  {selectedUser.displayInfo?.prolificPid && (
                    <Box>
                      <Text fontWeight="bold" mb={1}>Prolific PID:</Text>
                      <Code fontSize="xs" color="blue.600">{selectedUser.displayInfo.prolificPid}</Code>
                    </Box>
                  )}
                  <Box>
                    <Text fontWeight="bold" mb={1}>Progress:</Text>
                    <Text>{selectedUser.completedImages}/{selectedUser.totalImages} images ({selectedUser.completionPercentage}%)</Text>
                  </Box>
                  <Box>
                    <Text fontWeight="bold" mb={1}>Study Status:</Text>
                    <VStack align="start" spacing={1}>
                      <Badge colorScheme={selectedUser.hasConsented ? "green" : "red"}>
                        {selectedUser.hasConsented ? "âœ… Consented" : "âŒ No Consent"}
                      </Badge>
                      <Badge colorScheme={selectedUser.demographicsCompleted ? "purple" : "gray"}>
                        {selectedUser.demographicsCompleted ? "ğŸ“Š Demographics Done" : "ğŸ“Š Demographics Pending"}
                      </Badge>
                      <Badge colorScheme={selectedUser.isCompleted ? "green" : "blue"}>
                        {selectedUser.isCompleted ? "âœ… Completed" : "ğŸ”„ In Progress"}
                      </Badge>
                    </VStack>
                  </Box>
                  <Box>
                    <Text fontWeight="bold" mb={1}>User Type:</Text>
                    <HStack spacing={1} wrap="wrap">
                      {selectedUser.isPreAssigned && <Badge colorScheme="purple">Pre-assigned</Badge>}
                      {selectedUser.isTest && <Badge colorScheme="orange">Test</Badge>}
                      {selectedUser.isProlific && <Badge colorScheme="blue">Prolific</Badge>}
                      {selectedUser.isAutoGenerated && <Badge colorScheme="cyan">Auto-Generated ID</Badge>}
                    </HStack>
                  </Box>
                </SimpleGrid>
                
                {(selectedUser.prolificData || selectedUser.prolificPid) && (
                  <Box w="full">
                    <Text fontWeight="bold" mb={2}>Prolific Integration Data:</Text>
                    <Box bg="blue.50" p={3} borderRadius="md">
                      <VStack align="start" spacing={1}>
                        <Text fontSize="sm">
                          PID: <Code fontSize="xs">{selectedUser.prolificPid || selectedUser.prolificData?.prolificPid}</Code>
                        </Text>
                        {selectedUser.prolificData?.studyId && (
                          <Text fontSize="sm">
                            Study ID: <Code fontSize="xs">{selectedUser.prolificData.studyId}</Code>
                          </Text>
                        )}
                        {selectedUser.prolificData?.sessionId && (
                          <Text fontSize="sm">
                            Session ID: <Code fontSize="xs">{selectedUser.prolificData.sessionId}</Code>
                          </Text>
                        )}
                        {selectedUser.isAutoGenerated && (
                          <Text fontSize="sm">
                            <Badge colorScheme="green" size="sm">âœ“ Auto-Login System</Badge>
                          </Text>
                        )}
                      </VStack>
                    </Box>
                  </Box>
                )}

                {selectedUser.preAssignmentDetails && (
                  <Box w="full">
                    <Text fontWeight="bold" mb={2}>Pre-Assignment Details:</Text>
                    <Box bg="purple.50" p={3} borderRadius="md">
                      <VStack align="start" spacing={1}>
                        <Text fontSize="sm">Pre-assigned: <Code fontSize="xs">{selectedUser.preAssignedAt?.toDate?.()?.toLocaleString() || 'Yes'}</Code></Text>
                        <Text fontSize="sm">Set 1 Images: <Badge size="sm">{selectedUser.preAssignmentDetails.set1Count || 'N/A'}</Badge></Text>
                        <Text fontSize="sm">Set 2 Images: <Badge size="sm">{selectedUser.preAssignmentDetails.set2Count || 'N/A'}</Badge></Text>
                        <Text fontSize="sm">Total Images: <Badge size="sm">{selectedUser.preAssignmentDetails.imagesPerParticipant || selectedUser.totalImages}</Badge></Text>
                        {selectedUser.preAssignmentDetails.verifiedImages && (
                          <Text fontSize="sm">Verification: <Badge colorScheme="green" size="sm">âœ“ Images Verified</Badge></Text>
                        )}
                        {selectedUser.imageAssignmentStatus && (
                          <Text fontSize="sm">Assignment Status: <Badge colorScheme="blue" size="sm">{selectedUser.imageAssignmentStatus}</Badge></Text>
                        )}
                      </VStack>
                    </Box>
                  </Box>
                )}
                
                {selectedUser.assignedImages && (
                  <Box w="full">
                    <Text fontWeight="bold" mb={2}>Assigned Images ({selectedUser.assignedImages.length}):</Text>
                    <Box maxH="200px" overflowY="auto">
                      <UnorderedList spacing={1}>
                        {selectedUser.assignedImages.map((img, idx) => (
                          <ListItem key={idx} fontSize="sm">
                            <Code fontSize="xs">{img.id || img.name}</Code> - {img.set}
                            {selectedUser.completedImageIds?.includes(img.id || img.name) && (
                              <Badge ml={2} colorScheme="green" size="sm">Completed</Badge>
                            )}
                          </ListItem>
                        ))}
                      </UnorderedList>
                    </Box>
                  </Box>
                )}
              </VStack>
            )}
          </ModalBody>
          <ModalFooter>
            <Button onClick={onUserModalClose}>Close</Button>
          </ModalFooter>
        </ModalContent>
      </Modal>

      {/* Image Statistics Modal - Keep existing */}
      <Modal isOpen={isStatsModalOpen} onClose={onStatsModalClose} size="lg">
        <ModalOverlay />
        <ModalContent>
          <ModalHeader>Image Assignment Statistics</ModalHeader>
          <ModalCloseButton />
          <ModalBody pb={6}>
            {imageStats ? (
              <VStack spacing={6}>
                <SimpleGrid columns={2} spacing={6} w="full">
                  <Card>
                    <CardHeader>
                      <Heading size="sm">Set 1 (Images 1-1200)</Heading>
                    </CardHeader>
                    <CardBody>
                      <VStack spacing={2} align="start">
                        {Object.entries(imageStats.set1 || {}).map(([assignments, count]) => (
                          <HStack key={assignments} justify="space-between" w="full">
                            <Text fontSize="sm">{assignments} assignments:</Text>
                            <Badge>{count} images</Badge>
                          </HStack>
                        ))}
                      </VStack>
                    </CardBody>
                  </Card>
                  
                  <Card>
                    <CardHeader>
                      <Heading size="sm">Set 2 (Images 1201-2400)</Heading>
                    </CardHeader>
                    <CardBody>
                      <VStack spacing={2} align="start">
                        {Object.entries(imageStats.set2 || {}).map(([assignments, count]) => (
                          <HStack key={assignments} justify="space-between" w="full">
                            <Text fontSize="sm">{assignments} assignments:</Text>
                            <Badge>{count} images</Badge>
                          </HStack>
                        ))}
                      </VStack>
                    </CardBody>
                  </Card>
                </SimpleGrid>
              </VStack>
            ) : (
              <Text>Loading statistics...</Text>
            )}
          </ModalBody>
          <ModalFooter>
            <Button onClick={onStatsModalClose}>Close</Button>
          </ModalFooter>
        </ModalContent>
      </Modal>

      {/* Prolific URL Modal - Keep existing */}
      <Modal isOpen={isProlificModalOpen} onClose={onProlificModalClose} size="lg">
        <ModalOverlay />
        <ModalContent>
          <ModalHeader>Prolific Study URL</ModalHeader>
          <ModalCloseButton />
          <ModalBody pb={6}>
            <VStack spacing={4}>
              <Text fontSize="sm" color="gray.600">
                Use this URL as your study link in Prolific. The placeholders will be automatically replaced with participant data.
              </Text>
              
              <Box w="full">
                <HStack mb={2}>
                  <Text fontWeight="bold">Study URL:</Text>
                  <Button size="xs" onClick={() => copyToClipboard(prolificUrl)}>
                    ğŸ“‹ Copy
                  </Button>
                </HStack>
                <Textarea
                  value={prolificUrl}
                  isReadOnly
                  fontFamily="mono"
                  fontSize="sm"
                  rows={4}
                />
              </Box>
              
              <Alert status="info" size="sm">
                <AlertIcon />
                <Text fontSize="sm">
                  Participants will be automatically logged in when they click this link from Prolific.
                  Make sure to set the completion URL in Prolific to redirect participants 
                  back after they finish the study.
                </Text>
              </Alert>
              
              <Alert status="success" size="sm">
                <AlertIcon />
                <Text fontSize="sm">
                  <strong>âœ“ Auto-Login Integration Active:</strong> Participants will be seamlessly 
                  logged in with auto-generated IDs and their Prolific data will be captured automatically.
                </Text>
              </Alert>
            </VStack>
          </ModalBody>
          <ModalFooter>
            <Button onClick={onProlificModalClose}>Close</Button>
          </ModalFooter>
        </ModalContent>
      </Modal>
    </Box>
  );
};

export default AdminDashboard;